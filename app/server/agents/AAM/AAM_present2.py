# -*- coding: utf-8 -*-
"""MIRPR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JJnAQWA5B2ZDNZvrrYKvK5H3hK4LpLa5
"""
import menpo
import menpo.io as mio
from menpo.visualize import print_progress
from menpo.landmark import labeller, face_ibug_68_to_face_ibug_68_trimesh
from menpodetect import load_dlib_frontal_face_detector
from menpofit.aam import LucasKanadeAAMFitter, WibergInverseCompositional
from menpofit.aam import HolisticAAM
from menpofit.aam import PatchAAM
from menpo.feature.optional.vlfeat import fast_dsift
from pathlib import Path
import menpo.io as mio
import matplotlib.pyplot as plt
import pickle


class AAM_Class:

    def __init__(self, path_to_training_images, path_to_store_aam_model):
        self.path_to_training_images = path_to_training_images
        self.path_to_store_aam_model = path_to_store_aam_model

    def loadImages(self, path_to_training_images):
        training_images = []
        for img in print_progress(mio.import_images(path_to_training_images, verbose=True)):
            # convert to greyscale
            if img.n_channels == 3:
                img = img.as_greyscale()
            # crop to landmarks bounding box with an extra 20% padding
            img = img.crop_to_landmarks_proportion(0.2)
            # rescale image if its diagonal is bigger than 400 pixels
            d = img.diagonal()
            if d > 400:
                img = img.rescale(400.0 / d)
            # define a TriMesh which will be useful for Piecewise Affine Warp of HolisticAAM
            labeller(img, 'PTS', face_ibug_68_to_face_ibug_68_trimesh)
            # append to list
            training_images.append(img)
        return training_images

    def holisticAAM(self, training_images):
        aam = HolisticAAM(training_images, group='face_ibug_68_trimesh', diagonal=150,
                          scales=(0.5, 1.0), holistic_features=fast_dsift, verbose=True,
                          max_shape_components=20, max_appearance_components=150)
        # aam.view_aam_widget()

    def patchAAM(self, training_images):
        patch_aam = PatchAAM(training_images,
                             group='PTS',
                             patch_shape=[(15, 15), (23, 23)],
                             diagonal=150,
                             scales=(0.5, 1.0),
                             holistic_features=fast_dsift,
                             max_shape_components=20,
                             max_appearance_components=150,
                             verbose=True)
        return patch_aam

    def trainAAM(self, training_images):

        # aam = holisticAAM(training_images)        -> implemented
        # aam = maskedAAM(training_images)          -> unimplemented
        # aam = linearAAM(training_images)          -> unimplemented
        # aam = linearMaskedAAM(training_images)    -> unimplemented
        aam = self.patchAAM(training_images)  # -> implemented

        return aam

    def lucasKanadeAAMFitter(self, aam):
        patch_aam = aam
        fitter = LucasKanadeAAMFitter(patch_aam,
                                      lk_algorithm_cls=WibergInverseCompositional,
                                      n_shape=[5, 20],
                                      n_appearance=[30, 150])

        return fitter

    def trainFitter(self, aam):
        fitter = self.lucasKanadeAAMFitter(aam)
        return fitter

    def train(self):
        training_images = self.loadImages(self.path_to_training_images)
        aam = self.trainAAM(training_images)
        fitter = self.trainFitter(aam)

        return fitter

    def fittingByUrlWithoutGtShape(self, fitter, path_to_picture):

        image = mio.import_image(path_to_picture)
        image = image.as_greyscale()

        # print(image)

        # Load detector
        detect = load_dlib_frontal_face_detector()

        # Detect
        bboxes = detect(image)
        print("{} detected faces.".format(len(bboxes)))

        # View
        if len(bboxes) > 0:
            image.view_landmarks(group='dlib_0', line_colour='red',
                                 render_markers=False, line_width=4);

        # initial bbox
        initial_bbox = bboxes[0]

        print("len landmarks")
        print(bboxes[0].landmarks)
        print(bboxes[0].landmarks.values())
        print(len(bboxes[0].landmarks))
        print(bboxes[0].landmarks.n_dims)
        print(bboxes[0].landmarks.n_groups)
        print(bboxes[0].landmarks.view_widget)

        len(initial_bbox.landmarks)

        # fit image'
        # result = fitter.fit_from_bb(image, initial_bbox, max_iters=[15, 5],
        #                             gt_shape=image.landmarks['PTS'].lms)

        result = fitter.fit_from_bb(image, initial_bbox, max_iters=[15, 5])

        return result

    def fittingByUrlWithGtShape(self, fitter, path_to_picture):

        image = mio.import_image(path_to_picture)
        image = image.as_greyscale()

        # print(image)

        # Load detector
        detect = load_dlib_frontal_face_detector()

        # Detect
        bboxes = detect(image)
        print("{} detected faces.".format(len(bboxes)))

        # View
        if len(bboxes) > 0:
            image.view_landmarks(group='dlib_0', line_colour='red',
                                 render_markers=False, line_width=4);

        # initial bbox
        initial_bbox = bboxes[0]

        print("len landmarks")
        print(bboxes[0].landmarks)
        print(bboxes[0].landmarks.values())
        print(len(bboxes[0].landmarks))
        print(bboxes[0].landmarks.n_dims)
        print(bboxes[0].landmarks.n_groups)
        print(bboxes[0].landmarks.view_widget)

        len(initial_bbox.landmarks)

        # fit image'
        result = fitter.fit_from_bb(image, initial_bbox, max_iters=[15, 5],
                                    gt_shape=image.landmarks['PTS'].lms)
        print(result)

        return result

    def fittingByImage(self, fitter, image):

        image = image.as_greyscale()

        # print(image)

        # Load detector
        detect = load_dlib_frontal_face_detector()

        # Detect
        bboxes = detect(image)
        print("{} detected faces.".format(len(bboxes)))

        # View
        if len(bboxes) > 0:
            image.view_landmarks(group='dlib_0', line_colour='red',
                                 render_markers=False, line_width=4);

        # initial bbox
        initial_bbox = bboxes[0]

        '''
        print("len landmarks")
        print(bboxes[0].landmarks)
        print(bboxes[0].landmarks.values())
        print(len(bboxes[0].landmarks))
        print(bboxes[0].landmarks.n_dims)
        print(bboxes[0].landmarks.n_groups)
        print(bboxes[0].landmarks.view_widget)

        len(initial_bbox.landmarks)
        '''

        # fit image'
        # result = fitter.fit_from_bb(image, initial_bbox, max_iters=[15, 5],
        #                             gt_shape=image.landmarks['PTS'].lms)

        result = fitter.fit_from_bb(image, initial_bbox, max_iters=[15, 5])

        return result

    def saveModel(self, filename, whatToSave):
        outfile = open(filename, 'wb')

        pickle.dump(whatToSave, outfile)
        outfile.close()

    def loadModel(self, filename):
        infile = open(filename, 'rb')
        whatToLoad = pickle.load(infile)
        infile.close()
        return whatToLoad

    def print_things(self, fitter, result):

        '''
        #print(result.shape_parameters)
        print(result.appearance_parameters)
        '''

        '''
        # print result
        print(result)
        # asta va printa asta: Fitting result of 68 landmark points.
        '''

        '''
        print("=result from print_things333333333333333")
        print(result.is_iterative)
        # asta va print asta: True
        '''

        '''
        print("=the list of shape parameters obtained at each iteration of the fitting process")
        for line in result.shape_parameters:
            print(line)
        # asta va printa 22 de liste, primele 16 liste au cate 9 duble, ultimele 6 liste au cate 24 double
        '''

        '''
        print("=result from print_things444444444444444")
        print("=total number of iterations of the fitting process:")
        print(result.n_iters)
        # asta va printa asta: 20
        '''



        '''
        print("=the result of the reconstruction step")
        print(result.reconstructed_initial_shapes)
        # asta va printa asta: [PointCloud: n_points: 68, n_dims: 2, PointCloud: n_points: 68, n_dims: 2]
        '''

        '''
        print("=fitter")
        print(fitter)
        # asta va print o descriere a lui fitter
        '''

        '''
        print("=the list of shapes obtained at each iteration of the fitting process")
        print(result.shapes)
        # asta va prina asta:
        # "PointCloud: n_points: 68, n_dims: 2" de 23 de ori
        '''

        '''
        print("=initial shape that was provided to the fitting method to initialise the fitting process")
        print(result.initial_shape)
        # asta va printa asta:
        # "PointCloud: n_points: 68, n_dims: 2"
        '''

        '''
        print("=the ground truth shape associated with the image")
        print(result.gt_shape)
        # asta va print asta: None
        '''

        '''
        print("=the final shape of the fitting process")
        print(result.final_shape)
        # asta va printa asta:
        # "PointCloud: n_points: 68, n_dims: 2"
        '''

        '''
        print("= the list of appearance parameters obtained at each iteration of the fitting process")
        for line in result.appearance_parameters:
            print(line)
        for line in result.appearance_parameters:
            print(len(line))
        print(len(result.appearance_parameters))
        # asta va printa liste de double
        # fiecare lista are urmatoarele dimensiuni
        # 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 150, 150, 150, 150, 150, 150
        # sunt 22 de liste
        '''

        '''
        print("=displacements")
        for line in result.displacements():
            print(line)
        for line in result.displacements():
            print(len(line))
        print(len(result.displacements()))
        # asta va printa liste de double
        # fiecare lista are urmatoarele dimensiuni
        # 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68
        # sunt 22 de liste
        '''

        '''
        print("=displacements stats")
        for line in result.displacements_stats():
            print(line)
        # asta va printa 22 de double, majoritatea intre 0 si 1
        '''

        '''
        print("=try to export the final_shape")
        menpo.io.export_landmark_file(result.final_shape, 'final_shape.ljson', extension=None, overwrite=True)
        # asta face export la final_shape
        '''

        '''
        print("=try to export the initial_shape")
        menpo.io.export_landmark_file(result.initial_shape, 'initial_shape.ljson', extension=None, overwrite=True)
        # asta face export la initial_shape
        '''

        '''
        # print("=try to export the gt_shape")
        # menpo.io.export_landmark_file(result.gt_shape, 'gt_shape.ljson', extension=None, overwrite=True)
        # asta face export la gt_shape, dar trebuie sa existe gt_shape
        '''

        '''
        print("=try to import")
        res = menpo.io.import_landmark_file('final_shape.ljson')
        print(res)
        print("=try to print the points")
        print(res.points)
        print("=try to print the final shape")
        print(res.shape.affine_transforms)
        print(result.render_gt_shape)
        print(result.final_shape.points)

        # asta face import la final_shape si il printeaza
        '''

        x, y = result.final_shape.points.T
        # asta ia punctele in format x,y din final_shape

        plt.scatter(y, x)
        # asta pune punctele pe imagine
        plt.show()
        # asta afiseaza imaginea


        for points in result.final_shape.points:
            print(points)
        # asta afiseaza 68 double in consola



path_to_training_images = 'C:/Users/Catalin/Desktop/facultate/licenta/DB/lfpw/trainset/'
path_to_store_aam_model = 'fitter_save'
path_to_my_picture = Path('C:/Users/Catalin/Desktop/picture2.jpg')
path_to_their_picture = Path('C:/Users/Catalin/Desktop/facultate/licenta/DB/lfpw/testset/image_0018.png')

aam = AAM_Class(path_to_training_images, path_to_store_aam_model)

# model = aam.train()
# aam.saveModel(path_to_store_aam_model, model)

model = aam.loadModel(path_to_store_aam_model)
result = aam.fittingByUrlWithoutGtShape(model, path_to_my_picture)
# result = aam.fittingByUrlWithGtShape(model, path_to_their_picture)
aam.print_things(model, result)




